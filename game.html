<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Roger &amp; Chloe – Candy &amp; Flying Phases</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #f0f8ff;
      font-family: sans-serif;
      user-select: none;
      overflow: hidden;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #wrapper {
      display: flex;
      width: 1000px;
      height: 700px;
    }
    .sidebar {
      width: 150px;
      background: #fff;
      border: 2px solid #444;
      box-sizing: border-box;
      padding: 10px;
      overflow-y: auto;
    }
    .sidebar h3 {
      margin-top: 0;
      text-align: center;
    }
    #centerArea {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #gameContainer {
      position: relative;
      width: 800px;
      height: 600px;
      border: 2px solid #444;
      background: #000;
    }
    #gameCanvas {
      display: block;
      background: #000;
    }
    #powerUpDesc {
      width: 800px;
      padding: 6px 10px;
      background: #fff;
      border: 2px solid #444;
      border-top: none;
      box-sizing: border-box;
      font-size: 1rem;
      color: #111;
      min-height: 24px;
      margin-top: 4px;
    }
    .touch-zone {
      position: absolute;
      bottom: 10px;
      width: 80px;
      height: 80px;
      opacity: 0.25;
      touch-action: none;
      z-index: 10;
    }
    #chloe-left  { left:  10%; background: #ff1493; }
    #chloe-right { left:  25%; background: #ff1493; }
    #roger-left  { left:  65%; background: #0077cc; }
    #roger-right { left:  80%; background: #0077cc; }
    .sidebar::-webkit-scrollbar {
      width: 8px;
    }
    .sidebar::-webkit-scrollbar-track {
      background: #f1f1f1;
    }
    .sidebar::-webkit-scrollbar-thumb {
      background: #888;
    }
    .sidebar::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
  </style>
</head>
<body>
  <div id="wrapper">
    <div id="leftSidebar" class="sidebar">
      <h3>Roger Levels</h3>
      <ul id="rogerLevels"></ul>
    </div>
    <div id="centerArea">
      <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="chloe-left"  class="touch-zone"></div>
        <div id="chloe-right" class="touch-zone"></div>
        <div id="roger-left"  class="touch-zone"></div>
        <div id="roger-right" class="touch-zone"></div>
      </div>
      <div id="powerUpDesc"></div>
    </div>
    <div id="rightSidebar" class="sidebar">
      <h3>Chloe Levels</h3>
      <ul id="chloeLevels"></ul>
    </div>
  </div>

  <script>
    window.onload = () => {
      const canvas = document.getElementById("gameCanvas");
      const ctx    = canvas.getContext("2d");
      const W      = canvas.width;
      const H      = canvas.height;

      const leftList  = document.getElementById("rogerLevels");
      const rightList = document.getElementById("chloeLevels");
      const powerUpDescDiv = document.getElementById("powerUpDesc");

      let phase1Logged = false;
      let phase2Logged = false;

      const GRAVITY             = 0.5;
      const BOUNCE_VEL          = -12;
      const DOUBLE_BOUNCE_BOOST = -8;
      const FLY_SPEED           = 4;
      const GROUND_Y            = H;

      const trampolines = [
        { x: 100, y: H - 70,  width: 300, height: 20, color: "#664400", vx: 1 },
        { x: 250, y: H - 200, width: 200, height: 15, color: "#664400", vx: 1.5 },
        { x: 400, y: H - 300, width: 240, height: 15, color: "#664400", vx: 2 },
      ];

      const platforms = [
        { x: 100, y: 350, width: 200, height: 10, color: "#228B22" },
        { x: 400, y: 250, width: 180, height: 10, color: "#228B22" },
        { x: 250, y: 150, width: 220, height: 10, color: "#228B22" },
      ];

      const keys = {
        ArrowLeft:  false,
        ArrowRight: false,
        ArrowUp:    false,
        ArrowDown:  false,
        KeyA:       false,
        KeyD:       false,
        KeyW:       false,
        KeyS:       false,
      };

      let pinwheelAngle    = 0;
      let holdHands        = false;
      let isCelebrating    = false;
      let celebrateTimer   = 0;
      let holdHandsItem    = null;
      let handSpacing      = 0;
      let messageText      = "";
      let messageTimer     = 0;

      let megaSpeedActive   = false;
      let megaSpeedTimer    = 0;
      let slowCandyActive   = false;
      let slowCandyTimer    = 0;
      let hurricaneActive   = false;
      let hurricaneTimer    = 0;
      let hurricaneCount    = 0;
      const HURRICANE_DURATION = 1800;
      const HURRICANE_TOTAL   = 100;

      let flyingMode       = false;
      const clouds         = [];
      const birds          = [];
      const planes         = [];
      const flyingItems    = [];
      const flyingPowerUps = [];
      const flameRings     = [];

      const phase2Items    = []; // unicorns and fairies in level 2

      let rainbowActive    = false;
      let rainbowTimer     = 0;
      let gravityActive    = false;
      let gravityTimer     = 0;
      let magnetActive     = false;
      let magnetTimer      = 0;
      const magnetRadius   = 150;
      let cloudBounceActive= false;
      let cloudBounceTimer = 0;
      let hazeActive       = false;
      let hazeTimer        = 0;
      let compassActive    = false;
      let compassTimer     = 0;
      let mooncloakActive  = false;
      let mooncloakTimer   = 0;
      let turboActive      = false;
      let turboTimer       = 0;
      let nebulaActive     = false;
      let nebulaTimer      = 0;

      const powerUpDescriptions = {
        holdHands: "HOLD HANDS: Pause and link hands, both gain points from each candy.",
        stopHoldingHands: "STOP HANDS: Release from hold-hands mode.",
        megaSpeed: "MEGA SPEED: Double speed for 10s.",
        slowCandy: "SLOW CANDY: Candy falls at half speed for 10s.",
        candyHurricane: "CANDY HURRICANE: 100 rapid candies over 30s.",
        rainbowBoost: "RAINBOW BOOST: 1.5× flying speed & double points for 10s.",
        gravityShield: "GRAVITY SHIELD: Disable gravity for 8s.",
        magnetFeather: "MAGNET FEATHER: Attract collectibles for 10s.",
        cloudBounce: "CLOUD BOUNCE: Bounce off clouds for 7s.",
        windTunnel: "WIND TUNNEL: Instant upward boost +5 points.",
        starfieldBurst: "STARFIELD BURST: +2 bonus points from nearby collectibles.",
        moonlightCloak: "MOONLIGHT CLOAK: +50% points & avoid obstacles for 10s.",
        turboTrail: "TURBO TRAIL: +30% forward movement 8s, then flame ring for bonus.",
        nebulaStorm: "NEBULA STORM: Extra collectibles 5s, slow haze 3s.",
        crystalCompass: "CRYSTAL COMPASS: Arrow to nearest high-value collectible."
      };

      class Character {
        constructor(name, color, startX, controls) {
          this.name      = name;
          this.baseColor = color;
          this.width     = 40;
          this.height    = 60;
          this.x         = startX;
          this.y         = H - this.height;
          this.vx        = 0;
          this.vy        = 0;
          this.scoreCandy    = 0;
          this.scoreFlying   = 0;
          this.controls  = controls;
        }

        update(other) {
          if (isCelebrating || holdHands || flyingMode) return;

          let speed = 12;
          if (megaSpeedActive) speed *= 2;
          if (keys[this.controls.left])      this.vx = -speed;
          else if (keys[this.controls.right]) this.vx = speed;
          else this.vx = 0;
          this.x += this.vx;

          const onGround = this.y + this.height >= GROUND_Y;
          if (onGround && keys[this.controls.up]) {
            this.vy = BOUNCE_VEL;
            this.y  = GROUND_Y - this.height;
          }
          this.vy += GRAVITY;
          this.y  += this.vy;

          if (this.x < 0) this.x = 0;
          if (this.x + this.width > W) this.x = W - this.width;
          if (this.y + this.height > GROUND_Y) {
            this.y  = GROUND_Y - this.height;
            this.vy = 0;
          }
          if (this.y < 0) {
            this.y  = 0;
            this.vy = 0;
          }

          for (const t of trampolines) {
            if (
              this.vy > 0 &&
              this.y + this.height >= t.y &&
              this.y + this.height - this.vy <= t.y &&
              this.x + this.width > t.x &&
              this.x < t.x + t.width
            ) {
              this.vy = BOUNCE_VEL;
              this.y  = t.y - this.height;
              if (other.y + other.height < t.y && other.vy < 0) {
                other.vy += DOUBLE_BOUNCE_BOOST;
              }
            }
          }
        }

        draw() {
          let fillStyle = this.baseColor;
          let strokeStyle = null;
          if (this.scoreCandy >= 10 || this.scoreFlying >= 10) {
            const grad = ctx.createLinearGradient(
              this.x, this.y, this.x, this.y + this.height
            );
            grad.addColorStop(0, "red");
            grad.addColorStop(0.17, "orange");
            grad.addColorStop(0.34, "yellow");
            grad.addColorStop(0.51, "green");
            grad.addColorStop(0.68, "blue");
            grad.addColorStop(0.85, "indigo");
            grad.addColorStop(1, "violet");
            fillStyle = grad;
            strokeStyle = this.name === "Roger" ? "#0000ff" : "#ff1493";
          }
          ctx.fillStyle = fillStyle;
          ctx.fillRect(this.x, this.y, this.width, this.height);
          if (strokeStyle) {
            ctx.lineWidth = 4;
            ctx.strokeStyle = strokeStyle;
            ctx.strokeRect(this.x, this.y, this.width, this.height);
          }

          const eyeW = this.width * 0.2;
          const eyeH = this.height * 0.13;
          const eyeY = this.y + this.height * 0.2;
          const eyeX1 = this.x + this.width * 0.15;
          const eyeX2 = this.x + this.width * 0.65;
          ctx.fillStyle = "#fff";
          ctx.fillRect(eyeX1, eyeY, eyeW, eyeH);
          ctx.fillRect(eyeX2, eyeY, eyeW, eyeH);

          let mouthW = this.width * 0.6;
          let mouthH = this.height * 0.08;
          if (holdHands) {
            mouthW = this.width * 0.8;
            mouthH = this.height * 0.2;
          }
          const mouthX = this.x + (this.width - mouthW) / 2;
          const mouthY = this.y + this.height * 0.6;
          ctx.fillStyle = "#000";
          ctx.fillRect(mouthX, mouthY, mouthW, mouthH);

          if (this.scoreCandy >= 15 || this.scoreFlying >= 15) {
            const centerX = this.x + this.width / 2;
            const centerY = this.y;
            const radius  = this.width / 2;
            ctx.beginPath();
            ctx.fillStyle = "#fff";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.arc(centerX, centerY, radius, Math.PI, 0);
            ctx.fill();
            ctx.stroke();

            const pinColor = (this.scoreCandy >= 20 || this.scoreFlying >= 20) ? "gold" : "red";
            ctx.save();
            ctx.translate(centerX, centerY - radius * 0.5);
            ctx.rotate(pinwheelAngle);
            ctx.strokeStyle = pinColor;
            ctx.lineWidth = 4;
            const armLen = radius * 0.8;
            ctx.beginPath();
            ctx.moveTo(-armLen, -armLen);
            ctx.lineTo(armLen, armLen);
            ctx.moveTo(-armLen, armLen);
            ctx.lineTo(armLen, -armLen);
            ctx.stroke();
            ctx.restore();
          }
        }
      }

      class SpecialItem {
        constructor(type) {
          this.type   = type;
          this.width  = 100;
          this.height = 40;
          this.x      = Math.random() * (W - this.width);
          this.y      = -40;
          this.vy     = 1;
        }
        update() {
          if (!isCelebrating && !flyingMode) this.y += this.vy;
        }
        draw() {
          let wrapperColor;
          switch (this.type) {
            case "holdHands":         wrapperColor = "#FF69B4"; break;
            case "stopHoldingHands":  wrapperColor = "#888888"; break;
            case "megaSpeed":         wrapperColor = "#FFD700"; break;
            case "slowCandy":         wrapperColor = "#87CEEB"; break;
            case "candyHurricane":    wrapperColor = "#CE93D8"; break;
            default:                  wrapperColor = "#D2691E";
          }
          ctx.fillStyle = wrapperColor;
          ctx.fillRect(this.x, this.y, this.width, this.height);
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 2;
          ctx.strokeRect(this.x, this.y, this.width, this.height);
          ctx.fillStyle = "rgba(255,255,255,0.3)";
          for (let i = 10; i < this.width; i += 20) {
            ctx.fillRect(this.x + i, this.y, 10, this.height);
          }
          ctx.fillStyle = "#000";
          ctx.font = "12px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          let lines = [];
          switch (this.type) {
            case "holdHands": lines = ["HOLD HANDS"]; break;
            case "stopHoldingHands": lines = ["STOP HANDS"]; break;
            case "megaSpeed": lines = ["MEGA SPEED"]; break;
            case "slowCandy": lines = ["SLOW CANDY"]; break;
            case "candyHurricane": lines = ["CANDY", "HURRICANE"]; break;
          }
          const lineHeight = 14;
          const startY = this.y + (this.height - lines.length * lineHeight) / 2 + lineHeight / 2;
          for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], this.x + this.width / 2, startY + i * lineHeight);
          }
        }
        checkCatch(character) {
          return (
            this.x < character.x + character.width &&
            this.x + this.width > character.x &&
            this.y < character.y + character.height &&
            this.y + this.height > character.y
          );
        }
      }

      class Candy {
        constructor() {
          this.radius = 10;
          this.x      = Math.random() * (W - this.radius * 2) + this.radius;
          this.y      = -20;
          this.vy     = 3 + Math.random() * 2;
          const r = Math.random();
          if (r < 0.5) {
            this.type  = "regular";
            this.color = "#ff69b4";
          } else if (r < 0.8) {
            this.type  = "lollipop";
            this.color = "#ffa500";
          } else {
            this.type  = "chocolate";
            this.color = "#8B4513";
          }
        }
        update() {
          if (!isCelebrating && !flyingMode) {
            let speed = this.vy;
            if (slowCandyActive) speed *= 0.5;
            this.y += speed;
          }
        }
        draw() {
          if (this.type === "regular") {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.fillRect(this.x - this.radius / 2, this.y - 2, this.radius, 4);
          } else if (this.type === "lollipop") {
            const stickH = 20;
            ctx.fillStyle = "#fff";
            ctx.fillRect(this.x - 2, this.y, 4, stickH);
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.x - this.radius / 2, this.y);
            ctx.lineTo(this.x + this.radius / 2, this.y);
            ctx.moveTo(this.x, this.y - this.radius / 2);
            ctx.lineTo(this.x, this.y + this.radius / 2);
            ctx.stroke();
          } else if (this.type === "chocolate") {
            const w = 20, h = 12;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x - w / 2, this.y - h / 2, w, h);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(this.x - w / 2 + 5, this.y - h / 2);
            ctx.lineTo(this.x - w / 2 + 5, this.y + h / 2);
            ctx.moveTo(this.x + w / 2 - 5, this.y - h / 2);
            ctx.lineTo(this.x + w / 2 - 5, this.y + h / 2);
            ctx.moveTo(this.x - w / 2, this.y);
            ctx.lineTo(this.x + w / 2, this.y);
            ctx.stroke();
          }
        }
        checkCatch(character) {
          const dx   = this.x - (character.x + character.width / 2);
          const dy   = this.y - (character.y + character.height / 2);
          const dist = Math.hypot(dx, dy);
          return dist < this.radius + Math.max(character.width, character.height) / 2;
        }
      }

      class FlyingItem {
        constructor(type) {
          this.type   = type;
          this.radius = 20;
          this.x      = Math.random() * (W - this.radius * 2) + this.radius;
          this.y      = H + this.radius;
          this.vy     = (1 + Math.random() * 1.5) * -1;
        }
        update() {
          this.y += this.vy;
        }
        draw() {
          switch (this.type) {
            case "fairy":
              ctx.fillStyle = "#FFD700";
              const cx = this.x, cy = this.y;
              const r = this.radius;
              ctx.beginPath();
              for (let i = 0; i < 5; i++) {
                const theta = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                const x1 = cx + Math.cos(theta) * r;
                const y1 = cy + Math.sin(theta) * r;
                const theta2 = theta + Math.PI / 5;
                const x2 = cx + Math.cos(theta2) * (r / 2);
                const y2 = cy + Math.sin(theta2) * (r / 2);
                if (i === 0) ctx.moveTo(x1, y1);
                else ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
              }
              ctx.closePath();
              ctx.fill();
              break;
            case "unicorn":
              ctx.fillStyle = "#FFFFFF";
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
              ctx.fill();
              ctx.fillStyle = "#FFD700";
              ctx.beginPath();
              ctx.moveTo(this.x, this.y - this.radius);
              ctx.lineTo(this.x - 10, this.y - this.radius - 30);
              ctx.lineTo(this.x + 10, this.y - this.radius - 30);
              ctx.closePath();
              ctx.fill();
              break;
            case "icecream":
              ctx.fillStyle = "#DEB887";
              ctx.beginPath();
              ctx.moveTo(this.x, this.y + this.radius);
              ctx.lineTo(this.x - this.radius / 2, this.y - this.radius / 2);
              ctx.lineTo(this.x + this.radius / 2, this.y - this.radius / 2);
              ctx.closePath();
              ctx.fill();
              ctx.fillStyle = "#FFC0CB";
              ctx.beginPath();
              ctx.arc(this.x, this.y - this.radius / 2, this.radius, Math.PI, 0);
              ctx.fill();
              break;
          }
        }
        checkCatch(character) {
          const dx   = this.x - (character.x + character.width / 2);
          const dy   = this.y - (character.y + character.height / 2);
          const dist = Math.hypot(dx, dy);
          return dist < this.radius + Math.max(character.width, character.height) / 2;
        }
      }

      class Phase2Collectible {
        constructor(type) {
          this.type   = type;
          this.radius = 20;
          this.vx     = 0;
          this.vy     = 0;
          const side = Math.floor(Math.random() * 4);
          if (side === 0) { // top
            this.x = Math.random() * (W - this.radius * 2) + this.radius;
            this.y = -this.radius;
            this.vy = 1;
          } else if (side === 1) { // bottom
            this.x = Math.random() * (W - this.radius * 2) + this.radius;
            this.y = H + this.radius;
            this.vy = -1;
          } else if (side === 2) { // left
            this.x = -this.radius;
            this.y = Math.random() * (H - this.radius * 2) + this.radius;
            this.vx = 1;
          } else { // right
            this.x = W + this.radius;
            this.y = Math.random() * (H - this.radius * 2) + this.radius;
            this.vx = -1;
          }
          this.movingIn = true;
        }
        update() {
          if (this.movingIn) {
            this.x += this.vx;
            this.y += this.vy;
            if (
              (this.vy > 0 && this.y >= this.radius) ||
              (this.vy < 0 && this.y <= H - this.radius) ||
              (this.vx > 0 && this.x >= this.radius) ||
              (this.vx < 0 && this.x <= W - this.radius)
            ) {
              this.vx = 0;
              this.vy = 0;
              this.movingIn = false;
            }
          }
        }
        draw() {
          if (this.type === "fairy") {
            ctx.fillStyle = "#FFD700";
            const cx = this.x, cy = this.y;
            const r = this.radius;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
              const theta = (i * 2 * Math.PI) / 5 - Math.PI / 2;
              const x1 = cx + Math.cos(theta) * r;
              const y1 = cy + Math.sin(theta) * r;
              const theta2 = theta + Math.PI / 5;
              const x2 = cx + Math.cos(theta2) * (r / 2);
              const y2 = cy + Math.sin(theta2) * (r / 2);
              if (i === 0) ctx.moveTo(x1, y1);
              else ctx.lineTo(x1, y1);
              ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.fill();
          } else if (this.type === "unicorn") {
            ctx.fillStyle = "#FFFFFF";
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = "#FFD700";
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.radius);
            ctx.lineTo(this.x - 10, this.y - this.radius - 30);
            ctx.lineTo(this.x + 10, this.y - this.radius - 30);
            ctx.closePath();
            ctx.fill();
          }
        }
        checkCatch(character) {
          const dx   = this.x - (character.x + character.width / 2);
          const dy   = this.y - (character.y + character.height / 2);
          const dist = Math.hypot(dx, dy);
          return dist < this.radius + Math.max(character.width, character.height) / 2;
        }
      }

      class FlyingPowerUp {
        constructor(type) {
          this.type   = type;
          this.radius = 30;
          this.x      = Math.random() * (W - this.radius * 2) + this.radius;
          this.y      = H + this.radius;
          this.vy     = -1.5;
        }
        update() {
          this.y += this.vy;
        }
        draw() {
          ctx.lineWidth = 3;
          switch (this.type) {
            case "rainbowBoost":
              {
                const grad = ctx.createRadialGradient(this.x, this.y, 5, this.x, this.y, this.radius);
                grad.addColorStop(0, "red");
                grad.addColorStop(0.17, "orange");
                grad.addColorStop(0.34, "yellow");
                grad.addColorStop(0.51, "green");
                grad.addColorStop(0.68, "blue");
                grad.addColorStop(0.85, "indigo");
                grad.addColorStop(1, "violet");
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = "#000";
                ctx.stroke();
              }
              break;
            case "gravityShield":
              {
                ctx.strokeStyle = "#1E90FF";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fillStyle = "rgba(135,206,250,0.3)";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fill();
              }
              break;
            case "magnetFeather":
              {
                ctx.strokeStyle = "#FFFFFF";
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.radius);
                ctx.quadraticCurveTo(this.x + 15, this.y, this.x, this.y + this.radius);
                ctx.stroke();
                ctx.strokeStyle = "#000";
                ctx.stroke();
              }
              break;
            case "cloudBounce":
              {
                ctx.fillStyle = "#FFFFFF";
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.radius * 1.4, this.radius * 0.7, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = "#000";
                ctx.stroke();
              }
              break;
            case "windTunnel":
              {
                ctx.strokeStyle = "#FFFFFF";
                ctx.beginPath();
                for (let i = 0; i < 12; i++) {
                  const angle = i * 0.5;
                  const rad = (this.radius * i) / 12;
                  const px = this.x + rad * Math.cos(angle);
                  const py = this.y + rad * Math.sin(angle);
                  if (i === 0) ctx.moveTo(px, py);
                  else ctx.lineTo(px, py);
                }
                ctx.stroke();
                ctx.strokeStyle = "#000";
                ctx.stroke();
              }
              break;
            case "starfieldBurst":
              {
                ctx.fillStyle = "#FFD700";
                const cx = this.x, cy = this.y;
                const r = this.radius;
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                  const theta = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                  const x1 = cx + Math.cos(theta) * r;
                  const y1 = cy + Math.sin(theta) * r;
                  const theta2 = theta + Math.PI / 5;
                  const x2 = cx + Math.cos(theta2) * (r / 2);
                  const y2 = cy + Math.sin(theta2) * (r / 2);
                  if (i === 0) ctx.moveTo(x1, y1);
                  else ctx.lineTo(x1, y1);
                  ctx.lineTo(x2, y2);
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = "#000";
                ctx.stroke();
              }
              break;
            case "moonlightCloak":
              {
                ctx.fillStyle = "#FFFACD";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0.25 * Math.PI, 1.75 * Math.PI);
                ctx.arc(this.x + 12, this.y, this.radius, 1.75 * Math.PI, 0.25 * Math.PI, true);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = "#000";
                ctx.stroke();
              }
              break;
            case "turboTrail":
              {
                ctx.fillStyle = "#FF4500";
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + this.radius);
                ctx.lineTo(this.x - this.radius / 2, this.y - this.radius / 2);
                ctx.lineTo(this.x + this.radius / 2, this.y - this.radius / 2);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = "#000";
                ctx.stroke();
              }
              break;
            case "nebulaStorm":
              {
                ctx.fillStyle = "rgba(147,112,219,0.6)";
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.radius * 1.4, this.radius, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = "rgba(152,251,152,0.4)";
                ctx.beginPath();
                ctx.ellipse(this.x + 12, this.y - 12, this.radius, this.radius * 0.8, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = "#000";
                ctx.stroke();
              }
              break;
            case "crystalCompass":
              {
                ctx.fillStyle = "#E0FFFF";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.radius * 0.7, this.y);
                ctx.stroke();
              }
              break;
          }
        }
        checkCatch(character) {
          const dx   = this.x - (character.x + character.width / 2);
          const dy   = this.y - (character.y + character.height / 2);
          const dist = Math.hypot(dx, dy);
          return dist < this.radius + Math.max(character.width, character.height) / 2;
        }
      }

      class FlameRing {
        constructor(x, y) {
          this.x      = x;
          this.y      = y;
          this.radius = 0;
          this.maxR   = 100;
          this.life   = 30;
        }
        update() {
          if (this.life > 0) {
            this.radius += this.maxR / 30;
            this.life--;
          }
        }
        draw() {
          if (this.life > 0) {
            ctx.strokeStyle = "rgba(255,69,0, " + (this.life / 30) + ")";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
            ctx.stroke();
          }
        }
      }

      class Cloud {
        constructor() {
          this.x = Math.random() * W;
          this.y = Math.random() * H * 0.5;
          this.vx = 0.5 + Math.random();
          this.width = 100 + Math.random() * 80;
          this.height = 40 + Math.random() * 20;
        }
        update() {
          this.x += this.vx;
          if (this.x - this.width > W) {
            this.x = -this.width;
            this.y = Math.random() * H * 0.5;
          }
        }
        draw() {
          ctx.fillStyle = "#FFFFFF";
          ctx.beginPath();
          ctx.ellipse(this.x, this.y, this.width, this.height, 0, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      class Bird {
        constructor() {
          this.x = Math.random() * W;
          this.y = Math.random() * H * 0.5;
          this.vx = 2 + Math.random() * 2;
          this.size = 10 + Math.random() * 5;
        }
        update() {
          this.x += this.vx;
          if (this.x - this.size > W) {
            this.x = -this.size;
            this.y = Math.random() * H * 0.5;
          }
        }
        draw() {
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(this.x - this.size, this.y + this.size / 2);
          ctx.lineTo(this.x - this.size * 2, this.y);
          ctx.stroke();
        }
      }

      class Plane {
        constructor() {
          this.x = Math.random() * W;
          this.y = Math.random() * H * 0.5;
          this.vx = 3 + Math.random() * 2;
          this.width = 60;
          this.height = 20;
        }
        update() {
          this.x += this.vx;
          if (this.x - this.width > W) {
            this.x = -this.width;
            this.y = Math.random() * H * 0.5;
          }
        }
        draw() {
          ctx.fillStyle = "#808080";
          ctx.fillRect(this.x, this.y, this.width, this.height);
          ctx.fillStyle = "#000";
          ctx.fillRect(this.x + this.width - 10, this.y + 5, 10, 10);
        }
      }

      for (let i = 0; i < 6; i++) clouds.push(new Cloud());
      for (let i = 0; i < 4; i++) birds.push(new Bird());
      for (let i = 0; i < 3; i++) planes.push(new Plane());

      const roger = new Character(
        "Roger", "#0077cc",
        150,
        { left: "ArrowLeft", right: "ArrowRight", up: "ArrowUp", down: "ArrowDown" }
      );
      const chloe = new Character(
        "Chloe", "#ff1493",
        200,
        { left: "KeyA", right: "KeyD", up: "KeyW", down: "KeyS" }
      );

      const items = [];
      let frameCount = 0;
      const candyInterval       = 90;
      const holdHandsInterval   = 1800;
      const stopHoldInterval    = 800;
      const megaSpeedInterval   = 1200;
      const slowCandyInterval   = 1500;
      const hurricaneInterval   = 3000;

      const powerUpIntervals = {
        rainbowBoost:    600,
        gravityShield:   800,
        magnetFeather:  1000,
        cloudBounce:    1200,
        windTunnel:     1400,
        starfieldBurst: 1600,
        moonlightCloak: 1800,
        turboTrail:     2000,
        nebulaStorm:    2200,
        crystalCompass: 2400
      };

      function handleCharacterCollision(a, b) {
        if (
          a.vy > 0 &&
          a.y + a.height >= b.y &&
          a.y + a.height - a.vy <= b.y &&
          a.x + a.width > b.x &&
          a.x < b.x + b.width
        ) {
          a.y = b.y - a.height;
          a.vy = 0;
        }
      }

      function showPowerUpDescription(type) {
        powerUpDescDiv.innerText = powerUpDescriptions[type] || "";
      }

      function logPhase1() {
        if (!phase1Logged) {
          const liR = document.createElement("li");
          liR.innerText = `Phase 1: ${roger.scoreCandy}`;
          leftList.appendChild(liR);
          const liC = document.createElement("li");
          liC.innerText = `Phase 1: ${chloe.scoreCandy}`;
          rightList.appendChild(liC);
          phase1Logged = true;
        }
      }

      function logPhase2() {
        if (!phase2Logged) {
          const liR = document.createElement("li");
          liR.innerText = `Phase 2: ${roger.scoreFlying}`;
          leftList.appendChild(liR);
          const liC = document.createElement("li");
          liC.innerText = `Phase 2: ${chloe.scoreFlying}`;
          rightList.appendChild(liC);
          phase2Logged = true;
        }
      }

      function gameLoop() {
        frameCount++;
        ctx.clearRect(0, 0, W, H);

        pinwheelAngle += 0.1;

        trampolines.forEach(t => {
          if (!flyingMode) {
            t.x += t.vx;
            if (t.x <= 0 || t.x + t.width >= W) t.vx *= -1;
          }
        });

        if (!flyingMode && roger.scoreCandy >= 25 && chloe.scoreCandy >= 25 && !isCelebrating) {
          logPhase1();
          flyingMode = true;
          roger.scoreFlying = 0;
          chloe.scoreFlying = 0;
        }

        if (isCelebrating) {
          const targetY = H / 2 - roger.height / 2;
          const targetX1 = W / 2 - roger.width - 10;
          const targetX2 = W / 2 + 10;
          roger.x += (targetX1 - roger.x) * 0.05;
          roger.y += (targetY - roger.y) * 0.05;
          chloe.x += (targetX2 - chloe.x) * 0.05;
          chloe.y += (targetY - chloe.y) * 0.05;
          roger.draw();
          chloe.draw();
          celebrateTimer--;
          if (celebrateTimer <= 0) {
            holdHands = true;
            isCelebrating = false;
            handSpacing = chloe.x - roger.x;
            holdHandsItem = null;
            messageText = "Hold Hands!";
            messageTimer = 120;
          }
          requestAnimationFrame(gameLoop);
          return;
        }

        if (!flyingMode) {
          ctx.fillStyle = "#FFEFD5";
          ctx.fillRect(0, 0, W, H);
          ctx.fillStyle = "#FFF8DC";
          ctx.fillRect(0, H - 100, W, 100);
          ctx.fillStyle = "#8B4513";
          ctx.fillRect(50, 150, W - 100, 20);

          const jarColors = ["#FF6347", "#FFD700", "#98FB98", "#87CEFA"];
          jarColors.forEach((col, i) => {
            const jarX = 80 + i * 180;
            const jarY = 110;
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(jarX, jarY, 60, 80);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.strokeRect(jarX, jarY, 60, 80);
            ctx.fillStyle = col;
            for (let c = 0; c < 10; c++) {
              const cx = jarX + 10 + (c % 5) * 10;
              const cy = jarY + 20 + Math.floor(c / 5) * 20;
              ctx.beginPath();
              ctx.arc(cx, cy, 6, 0, 2 * Math.PI);
              ctx.fill();
            }
            ctx.fillStyle = "#C0C0C0";
            ctx.fillRect(jarX - 5, jarY - 10, 70, 10);
            ctx.strokeRect(jarX - 5, jarY - 10, 70, 10);
          });

          trampolines.forEach(t => {
            ctx.fillStyle = t.color;
            ctx.fillRect(t.x, t.y, t.width, t.height);
          });

          if (holdHands) {
            if (keys["ArrowLeft"])  roger.x -= 12;
            else if (keys["ArrowRight"]) roger.x += 12;
            const onGround = roger.y + roger.height >= GROUND_Y;
            if (onGround && keys["ArrowUp"]) {
              roger.vy = BOUNCE_VEL;
              roger.y  = GROUND_Y - roger.height;
              chloe.vy = roger.vy;
              chloe.y  = roger.y;
            }
            roger.vy += GRAVITY;
            roger.y  += roger.vy;
            chloe.vy = roger.vy;
            chloe.y  = roger.y;

            if (roger.x < 0) roger.x = 0;
            if (roger.x + roger.width > W) roger.x = W - roger.width;
            chloe.x = roger.x + handSpacing;
            if (chloe.x + chloe.width > W) {
              chloe.x = W - chloe.width;
              roger.x = chloe.x - handSpacing;
            }
            if (roger.y + roger.height > GROUND_Y) {
              roger.y  = GROUND_Y - roger.height;
              roger.vy = 0;
              chloe.y  = roger.y;
              chloe.vy = 0;
            }
            if (roger.y < 0) {
              roger.y  = 0;
              roger.vy = 0;
              chloe.y  = roger.y;
              chloe.vy = 0;
            }
            trampolines.forEach(t => {
              if (
                roger.vy > 0 &&
                roger.y + roger.height >= t.y &&
                (roger.y + roger.height - roger.vy) <= t.y &&
                roger.x + roger.width > t.x &&
                roger.x < t.x + t.width
              ) {
                roger.vy = BOUNCE_VEL;
                roger.y  = t.y - roger.height;
                chloe.vy = roger.vy;
                chloe.y  = roger.y;
              }
            });
            roger.draw();
            chloe.x = roger.x + handSpacing;
            chloe.y = roger.y;
            chloe.draw();

            const yMid = roger.y + roger.height * 0.5;
            const rogerHandX = roger.x + roger.width;
            const chloeHandX = chloe.x;
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(rogerHandX, yMid);
            ctx.lineTo(chloeHandX, yMid);
            ctx.stroke();
            ctx.fillStyle = "#000";
            ctx.fillRect(rogerHandX - 4, yMid - 4, 8, 8);
            ctx.fillRect(chloeHandX - 4, yMid - 4, 8, 8);

          } else {
            roger.update(chloe);
            chloe.update(roger);
            handleCharacterCollision(roger, chloe);
            handleCharacterCollision(chloe, roger);
            roger.draw();
            chloe.draw();
          }

          if (frameCount % candyInterval === 0) {
            items.push(new Candy());
          }
          if (!holdHands && frameCount % holdHandsInterval === 0 && !holdHandsItem) {
            holdHandsItem = new SpecialItem("holdHands");
            items.push(holdHandsItem);
          }
          if (holdHands && frameCount % stopHoldInterval === 0) {
            items.push(new SpecialItem("stopHoldingHands"));
          }
          if (frameCount % megaSpeedInterval === 0) {
            items.push(new SpecialItem("megaSpeed"));
          }
          if (frameCount % slowCandyInterval === 0) {
            items.push(new SpecialItem("slowCandy"));
          }
          if (!hurricaneActive && frameCount % hurricaneInterval === 0) {
            items.push(new SpecialItem("candyHurricane"));
          }

          for (let i = items.length - 1; i >= 0; i--) {
            const itm = items[i];
            itm.update();
            itm.draw();

            if (itm instanceof SpecialItem) {
              if (itm === holdHandsItem) {
                if (itm.checkCatch(roger) || itm.checkCatch(chloe)) {
                  isCelebrating = true;
                  celebrateTimer = 120;
                  showPowerUpDescription("holdHands");
                  items.splice(i, 1);
                  continue;
                }
                if (itm.y - itm.height > H) {
                  holdHandsItem = null;
                  items.splice(i, 1);
                }
                continue;
              }
              if (itm.checkCatch(roger) || itm.checkCatch(chloe)) {
                switch (itm.type) {
                  case "stopHoldingHands":
                    holdHands = false;
                    showPowerUpDescription("stopHoldingHands");
                    messageText = "Stop Holding Hands!";
                    messageTimer = 120;
                    break;
                  case "megaSpeed":
                    megaSpeedActive = true;
                    megaSpeedTimer  = 600;
                    showPowerUpDescription("megaSpeed");
                    messageText = "Mega Speed!";
                    messageTimer = 120;
                    break;
                  case "slowCandy":
                    slowCandyActive = true;
                    slowCandyTimer  = 600;
                    showPowerUpDescription("slowCandy");
                    messageText = "Slow Candy!";
                    messageTimer = 120;
                    break;
                  case "candyHurricane":
                    hurricaneActive = true;
                    hurricaneTimer  = HURRICANE_DURATION;
                    hurricaneCount  = 0;
                    showPowerUpDescription("candyHurricane");
                    messageText = "Candy Hurricane!";
                    messageTimer = 120;
                    break;
                }
                items.splice(i, 1);
                continue;
              }
              if (itm.y - itm.height > H) {
                items.splice(i, 1);
              }
            } else {
              const caughtRoger = itm.checkCatch(roger);
              const caughtChloe = itm.checkCatch(chloe);
              if (caughtRoger || caughtChloe) {
                if (holdHands) {
                  roger.scoreCandy++;
                  chloe.scoreCandy++;
                } else if (caughtRoger) {
                  roger.scoreCandy++;
                } else {
                  chloe.scoreCandy++;
                }
                if (!holdHands) {
                  if (caughtRoger && roger.scoreCandy < 25 && roger.scoreCandy % 5 === 0) {
                    const oldW = roger.width, oldH = roger.height;
                    roger.width  += 10;
                    roger.height += 15;
                    roger.x -= (roger.width  - oldW) / 2;
                    roger.y -= (roger.height - oldH) / 2;
                  }
                  if (caughtChloe && chloe.scoreCandy < 25 && chloe.scoreCandy % 5 === 0) {
                    const oldW = chloe.width, oldH = chloe.height;
                    chloe.width  += 10;
                    chloe.height += 15;
                    chloe.x -= (chloe.width  - oldW) / 2;
                    chloe.y -= (chloe.height - oldH) / 2;
                  }
                } else {
                  if (roger.scoreCandy < 25 && roger.scoreCandy % 5 === 0) {
                    const oldW = roger.width, oldH = roger.height;
                    roger.width  += 10;
                    roger.height += 15;
                    chloe.width  += 10;
                    chloe.height += 15;
                    roger.x -= (roger.width  - oldW) / 2;
                    roger.y -= (roger.height - oldH) / 2;
                    chloe.x = roger.x + handSpacing;
                    chloe.y = roger.y;
                  }
                }
                items.splice(i, 1);
                continue;
              }
              if (itm.y - itm.radius > H) {
                items.splice(i, 1);
              }
            }
          }

          if (megaSpeedActive) {
            megaSpeedTimer--;
            if (megaSpeedTimer <= 0) megaSpeedActive = false;
          }
          if (slowCandyActive) {
            slowCandyTimer--;
            if (slowCandyTimer <= 0) slowCandyActive = false;
          }
          if (hurricaneActive) {
            hurricaneTimer--;
            if (hurricaneCount < HURRICANE_TOTAL && frameCount % 10 === 0) {
              items.push(new Candy());
              hurricaneCount++;
            }
            if (hurricaneTimer <= 0) {
              hurricaneActive = false;
            }
          }

          if (messageTimer > 0) {
            messageTimer--;
            ctx.fillStyle = "#000";
            ctx.font = "30px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(messageText, W / 2, 50);
          }

        } else {
          ctx.fillStyle = "#87CEEB";
          ctx.fillRect(0, 0, W, H);

          ctx.fillStyle = "#FFD700";
          ctx.beginPath();
          ctx.arc(80, 80, 50, 0, 2 * Math.PI);
          ctx.fill();

          clouds.forEach(c => {
            c.update();
            c.draw();
          });
          birds.forEach(b => {
            b.update();
            b.draw();
          });
          planes.forEach(p => {
            p.update();
            p.draw();
          });

          platforms.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.width, p.height);
          });

          Object.entries(powerUpIntervals).forEach(([type, interval]) => {
            if (frameCount % interval === 0) {
              flyingPowerUps.push(new FlyingPowerUp(type));
            }
          });

          if (frameCount % 120 === 0) {
            const types = ["fairy", "unicorn"];
            const t = types[Math.floor(Math.random() * types.length)];
            phase2Items.push(new Phase2Collectible(t));
          }

          const moveFactor = hazeActive ? 0.8 : 1;
          if (keys["ArrowLeft"])  roger.x -= FLY_SPEED * moveFactor * (rainbowActive ? 1.5 : 1);
          else if (keys["ArrowRight"]) roger.x += FLY_SPEED * moveFactor * (rainbowActive ? 1.5 : 1);
          if (keys["ArrowUp"])    roger.y -= FLY_SPEED * moveFactor * (rainbowActive ? 1.5 : 1);
          else if (keys["ArrowDown"]) roger.y += FLY_SPEED * moveFactor * (rainbowActive ? 1.5 : 1);

          if (keys["KeyA"])  chloe.x -= FLY_SPEED * moveFactor * (rainbowActive ? 1.5 : 1);
          else if (keys["KeyD"]) chloe.x += FLY_SPEED * moveFactor * (rainbowActive ? 1.5 : 1);
          if (keys["KeyW"])    chloe.y -= FLY_SPEED * moveFactor * (rainbowActive ? 1.5 : 1);
          else if (keys["KeyS"]) chloe.y += FLY_SPEED * moveFactor * (rainbowActive ? 1.5 : 1);

          [roger, chloe].forEach(ch => {
            if (ch.x < 0) ch.x = 0;
            if (ch.x + ch.width > W) ch.x = W - ch.width;
            if (ch.y < 0) ch.y = 0;
            if (ch.y + ch.height > H) ch.y = H - ch.height;

            platforms.forEach(p => {
              if (
                ch.y + ch.height <= p.y + 5 &&
                ch.y + ch.height + 5 >= p.y &&
                ch.x + ch.width > p.x &&
                ch.x < p.x + p.width
              ) {
                ch.y = p.y - ch.height;
              }
            });
          });

          roger.draw();
          chloe.draw();

          for (let i = flyingItems.length - 1; i >= 0; i--) {
            const fitm = flyingItems[i];
            fitm.update();
            fitm.draw();
            const caughtR = fitm.checkCatch(roger);
            const caughtC = fitm.checkCatch(chloe);
            if (caughtR || caughtC) {
              let points = fitm.type === "unicorn" ? 3 : (fitm.type === "icecream" ? 2 : 1);
              if (rainbowActive) points *= 2;
              if (mooncloakActive) points = Math.ceil(points * 1.5);
              if (caughtR) roger.scoreFlying += points;
              if (caughtC) chloe.scoreFlying += points;
              flyingItems.splice(i, 1);
            } else if (fitm.y + fitm.radius < 0) {
              flyingItems.splice(i, 1);
            }
          }

          if (magnetActive) {
            [roger, chloe].forEach(ch => {
              flyingItems.forEach(fitm => {
                const dx = ch.x + ch.width / 2 - fitm.x;
                const dy = ch.y + ch.height / 2 - fitm.y;
                const dist = Math.hypot(dx, dy);
                if (dist < magnetRadius) {
                  fitm.x += dx / dist * 2;
                  fitm.y += dy / dist * 2;
                }
              });
            });
          }

          for (let i = flyingPowerUps.length - 1; i >= 0; i--) {
            const pup = flyingPowerUps[i];
            pup.update();
            pup.draw();
            const caughtR = pup.checkCatch(roger);
            const caughtC = pup.checkCatch(chloe);
            if (caughtR || caughtC) {
              showPowerUpDescription(pup.type);
              switch (pup.type) {
                case "rainbowBoost":
                  rainbowActive = true;
                  rainbowTimer = 600;
                  messageText = "Rainbow Boost!";
                  messageTimer = 120;
                  break;
                case "gravityShield":
                  gravityActive = true;
                  gravityTimer = 480;
                  messageText = "Gravity Shield!";
                  messageTimer = 120;
                  break;
                case "magnetFeather":
                  magnetActive = true;
                  magnetTimer = 600;
                  messageText = "Magnet Feather!";
                  messageTimer = 120;
                  break;
                case "cloudBounce":
                  cloudBounceActive = true;
                  cloudBounceTimer = 420;
                  messageText = "Cloud Bounce!";
                  messageTimer = 120;
                  break;
                case "windTunnel":
                  [roger, chloe].forEach(ch => {
                    if (
                      pup.x > ch.x &&
                      pup.x < ch.x + ch.width &&
                      pup.y > ch.y &&
                      pup.y < ch.y + ch.height
                    ) {
                      ch.y -= 200;
                      ch.scoreFlying += 5;
                    }
                  });
                  messageText = "Wind Tunnel!";
                  messageTimer = 120;
                  break;
                case "starfieldBurst":
                  [roger, chloe].forEach(ch => {
                    flyingItems.forEach((fitm, idx) => {
                      const dx = ch.x + ch.width / 2 - fitm.x;
                      const dy = ch.y + ch.height / 2 - fitm.y;
                      const dist = Math.hypot(dx, dy);
                      if (dist < 150) {
                        const bonus = 2;
                        if (fitm.checkCatch(roger)) roger.scoreFlying += bonus;
                        if (fitm.checkCatch(chloe)) chloe.scoreFlying += bonus;
                        flyingItems.splice(idx, 1);
                      }
                    });
                  });
                  messageText = "Starfield Burst!";
                  messageTimer = 120;
                  break;
                case "moonlightCloak":
                  mooncloakActive = true;
                  mooncloakTimer = 600;
                  messageText = "Moonlight Cloak!";
                  messageTimer = 120;
                  break;
                case "turboTrail":
                  turboActive = true;
                  turboTimer = 480;
                  messageText = "Turbo Trail!";
                  messageTimer = 120;
                  break;
                case "nebulaStorm":
                  nebulaActive = true;
                  nebulaTimer = 300;
                  hazeActive = false;
                  messageText = "Nebula Storm!";
                  messageTimer = 120;
                  break;
                case "crystalCompass":
                  compassActive = true;
                  compassTimer = 600;
                  messageText = "Crystal Compass!";
                  messageTimer = 120;
                  break;
              }
              flyingPowerUps.splice(i, 1);
              continue;
            } else if (pup.y + pup.radius < 0) {
              flyingPowerUps.splice(i, 1);
            }
          }

          for (let i = flameRings.length - 1; i >= 0; i--) {
            const fr = flameRings[i];
            fr.update();
            fr.draw();
            if (fr.life <= 0) flameRings.splice(i, 1);
            else {
              flyingItems.forEach((fitm, idx) => {
                const dx = fitm.x - fr.x;
                const dy = fitm.y - fr.y;
                const dist = Math.hypot(dx, dy);
                if (dist < fr.radius) {
                  roger.scoreFlying++;
                  chloe.scoreFlying++;
                  flyingItems.splice(idx, 1);
                }
              });
            }
          }

          if (compassActive) {
            [roger, chloe].forEach(ch => {
              let nearest = null;
              let minDist = Infinity;
              flyingItems.forEach(fitm => {
                if (fitm.type === "unicorn" || fitm.type === "icecream") {
                  const dx = fitm.x - (ch.x + ch.width / 2);
                  const dy = fitm.y - (ch.y + ch.height / 2);
                  const dist = Math.hypot(dx, dy);
                  if (dist < minDist) {
                    minDist = dist;
                    nearest = fitm;
                  }
                }
              });
              if (nearest) {
                const dx = nearest.x - (ch.x + ch.width / 2);
                const dy = nearest.y - (ch.y + ch.height / 2);
                const angle = Math.atan2(dy, dx);
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(ch.x + ch.width / 2, ch.y + ch.height / 2);
                ctx.lineTo(
                  ch.x + ch.width / 2 + Math.cos(angle) * 30,
                  ch.y + ch.height / 2 + Math.sin(angle) * 30
                );
                ctx.stroke();
              }
            });
          }

          // Phase2 collectible handling
          for (let i = phase2Items.length - 1; i >= 0; i--) {
            const itm = phase2Items[i];
            itm.update();
            itm.draw();
            const caughtR = itm.checkCatch(roger);
            const caughtC = itm.checkCatch(chloe);
            if (caughtR || caughtC) {
              let points = itm.type === "unicorn" ? 3 : 1;
              if (rainbowActive) points *= 2;
              if (caughtR) roger.scoreFlying += points;
              if (caughtC) chloe.scoreFlying += points;
              phase2Items.splice(i, 1);
            }
          }

          if (rainbowActive) {
            rainbowTimer--;
            if (rainbowTimer <= 0) rainbowActive = false;
          }
          if (gravityActive) {
            gravityTimer--;
            if (gravityTimer <= 0) gravityActive = false;
          }
          if (magnetActive) {
            magnetTimer--;
            if (magnetTimer <= 0) magnetActive = false;
          }
          if (cloudBounceActive) {
            cloudBounceTimer--;
            if (cloudBounceTimer <= 0) cloudBounceActive = false;
          }
          if (nebulaActive) {
            nebulaTimer--;
            if (frameCount % 30 === 0) {
              const types = ["fairy", "unicorn", "icecream"];
              const t = types[Math.floor(Math.random() * types.length)];
              flyingItems.push(new FlyingItem(t));
            }
            if (nebulaTimer <= 0) {
              nebulaActive = false;
              hazeActive = true;
              hazeTimer = 180;
            }
          }
          if (hazeActive) {
            hazeTimer--;
            if (hazeTimer <= 0) hazeActive = false;
          }
          if (mooncloakActive) {
            mooncloakTimer--;
            if (mooncloakTimer <= 0) mooncloakActive = false;
          }
          if (turboActive) {
            turboTimer--;
            if (turboTimer <= 0) {
              turboActive = false;
              flameRings.push(new FlameRing(roger.x + roger.width / 2, roger.y + roger.height / 2));
              flameRings.push(new FlameRing(chloe.x + chloe.width / 2, chloe.y + chloe.height / 2));
            }
          }
          if (compassActive) {
            compassTimer--;
            if (compassTimer <= 0) compassActive = false;
          }

          if (!phase2Logged && roger.scoreFlying >= 50 && chloe.scoreFlying >= 50) {
            logPhase2();
          }
        }

        if (messageTimer > 0) {
          messageTimer--;
          ctx.fillStyle = "#000";
          ctx.font = "30px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(messageText, W / 2, 50);
        }

        requestAnimationFrame(gameLoop);
      }

      window.addEventListener("keydown", e => {
        if (e.code in keys) keys[e.code] = true;
      });
      window.addEventListener("keyup", e => {
        if (e.code in keys) keys[e.code] = false;
      });

      function bindTouch(zoneId, keyCode) {
        const zone = document.getElementById(zoneId);
        zone.addEventListener("touchstart", e => {
          e.preventDefault();
          keys[keyCode] = true;
        });
        zone.addEventListener("touchend", e => {
          e.preventDefault();
          keys[keyCode] = false;
        });
      }
      bindTouch("chloe-left",  "KeyA");
      bindTouch("chloe-right", "KeyD");
      bindTouch("roger-left",  "ArrowLeft");
      bindTouch("roger-right", "ArrowRight");

      gameLoop();
    };
  </script>
</body>
</html>
